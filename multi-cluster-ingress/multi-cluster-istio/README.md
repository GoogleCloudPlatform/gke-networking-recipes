# Multi Cluster Ingress with Istio Ingress-gateway

[Multi-cluster Ingress](https://cloud.google.com/kubernetes-engine/docs/concepts/multi-cluster-ingress) for GKE is a cloud-hosted Ingress controller for GKE clusters. It's a Google-hosted service that supports deploying shared load balancing resources across clusters and across regions.

This recipe demonstrate how we can deploy an Istio Ingress Gateway behind Multi-Cluster Ingress GCLB and how to take advantage of some [GKE Ingress features](https://cloud.google.com/kubernetes-engine/docs/how-to/ingress-features#request_headers) to customize HealthCheck. For details on how to use Istio Ingress Gateway with Ingress on a single cluster, you can check this [recipe](../ingress/istio-ingress-e2e-tls)

Deploying the Istio Ingress Gateway behind Multi-Cluster has many advantages:
- Defense on the edge instead of inside the Cluster using Google Global Load Balancers.
- Disaster recovery for internet traffic across clusters or regions
- Flexible migration between clusters
- Low-latency serving of traffic to globally distributed GKE clusters

### Use-cases

- Deploying Istio with an Ingess Gateway and mTLS enabled 
- Customizing GCLB HealthCheck paths and ports 
- Exposing the Istio Ingress Gateway behind an HTTP Load Balancer across clusters in 2 cloud regions

### Relevant documentation

- [GKE Ingress Concepts](https://cloud.google.com/kubernetes-engine/docs/concepts/ingress)
- [GKE Ingress Features](https://cloud.google.com/kubernetes-engine/docs/how-to/ingress-features)
- [Multi-cluster Ingress Concepts](https://cloud.google.com/kubernetes-engine/docs/concepts/ingress-for-anthos)
- [Setting Up Multi-cluster Ingress](https://cloud.google.com/kubernetes-engine/docs/how-to/ingress-for-anthos-setup)
- [Deploying Ingress Across Clusters
](https://cloud.google.com/kubernetes-engine/docs/how-to/ingress-for-anthos)
- [Secure Istio Gateway](https://istio.io/v1.7/docs/tasks/traffic-management/ingress/secure-ingress/)

#### Versions & Compatibility

- GKE clusters on GCP
- All versions of GKE supported
- Tested and validated with 1.18.12-gke.1201 on Jan 15th 2021

This recipe exposes one Service hosted on two GKE clusters in two Google Cloud Regions (//TODO: add the clusters regions) to the internet through a Multi-Cluster Ingress Resource. The HTTP LoadBalancer configured by MCI will have a single Global public VIP which will be used to receive user traffic and will route it to the closest cluster. We will test this by creating two VM's in the same regions as the clusters to mimic a user and verify that the traffic is routed properly and that the cluster closests to the user is the one replying. 

For the purposes of simplicity we will expose the service on HTTP. Please not that it's possible to use an HTTPS LoadBalancer on MCI using [Pre-Shared certificates](https://cloud.google.com/kubernetes-engine/docs/how-to/multi-cluster-ingress#pre-shared_certificates)


![secure ingress](//TODO: update diagram)

### Istio Manifests file operator.yaml

You will be using the [Istio Operator API](https://istio.io/latest/docs/setup/install/operator/) to customize the Istio installation.

Looking at the operator file below, here a breakdown of the cutomization needed.

- `enableAutoMtls`: enabled mTLS inside the Istio Mesh
- `k8s`: overrides the Service definition of the `istio-ingressgateway` to change it's type to `ClusterIP` from the default `LoadBalancer` and exposes the status port `15020` only. We technically don't need the generated Kubernetes Service for the istio-ingressgateway but the Operator doesn't offer a way to disable it. in MCI the needed Kubernetes Services are generated by the [MultiClusterService](//TODO: add link) CRD

```yaml
apiVersion: install.istio.io/v1alpha1
kind: IstioOperator
spec:
  profile: default
  meshConfig:
    accessLogFile: /dev/stdout
    outboundTrafficPolicy: 
      mode: ALLOW_ANY
    enableAutoMtls: true
  components:
    ingressGateways:
    - name: istio-ingressgateway
      enabled: true
      k8s:
        service:
          type: ClusterIP
          ports:
          - name: status-port
            port: 15020
            targetPort: 15021
```

### Multi-Cluster Manifests file mci-manifests.yaml

Several declarative Kubernetes resources are used in the deployment of this recipe. First we deploy a  [BackendConfig](https://cloud.google.com/kubernetes-engine/docs/how-to/ingress-features#direct_health) which customizes the LoadBalancer HealthCheck path and port to the ones supported by the `istio-ingressgateway`. The `istio-ingressgateway` serves traffic on port `80` for http (and optionaly 443 for https which is out of scope of this recipe) on the `/` path in this case. But the HealthCheck status is served on port `15021` on the `/healthz/ready path`

```yaml
apiVersion: cloud.google.com/v1
kind: BackendConfig
metadata:
  name: istio-ingress-be-config
  namespace: istio-system
spec:
  healthCheck:
    checkIntervalSec: 3
    timeoutSec: 1
    healthyThreshold: 3
    unhealthyThreshold: 2
    type: HTTP
    requestPath: /healthz/ready
    port: 15021
```

The next two resources are the primary ones for MCI. The `MultiClusterService` and `MultiClusterIngress` resources. Both are deployed only to the [Config Cluster](//TODO: add link)

The MultiClusterService describes the istio-ingressgateway across the clusters that are part of the deployment:

- The `beta.cloud.google.com/backend-config` annotations points to the `BackendConfig` described above.
- The ports declares needed ports for serving healthCheck and app traffic

```yaml
apiVersion: networking.gke.io/v1
kind: MultiClusterService
metadata:
  name: istio-ingressgateway-mcs
  namespace: istio-system
  annotations:
    beta.cloud.google.com/backend-config: '{"default":"istio-ingress-be-config"}'
spec:
  template:
    spec:
      selector:
        app: istio-ingressgateway
        istio: ingressgateway
      ports:
      - name: status-port
        protocol: TCP
        port: 15020
        targetPort: 15021
      - name: http
        protocol: TCP
        port: 80
        targetPort: 8080
```
The MultiClusterIngress references the MultiClusterService described above and generates the underlying LoadBalancer resources. I contains one annotation which points to the static Global IP reserved for the LoadBalancer.

```yaml
apiVersion: networking.gke.io/v1
kind: MultiClusterIngress
metadata:
  name: istio-ingressgateway-ingress
  namespace: istio-system
  annotations:
    networking.gke.io/static-ip: 35.227.196.240
spec:
  template:
    spec:
      backend:
        serviceName: istio-ingressgateway-mcs
        servicePort: 80
```
### App Manifests file app-manifests.yaml

The `Gateway` Object performs the following:

- Accepts traffic coming via the LoadBalancer via the `hosts` value set to `*`
- Presents a TLS certificate to the LoadBalancer, the Certificate and private Key are store in Kubernetes secrets under `whereami-credentials`.
- Set the minimum protocol Version of TLS to 1.2

```yaml
apiVersion: networking.istio.io/v1alpha3
kind: Gateway
metadata:
  name: istio-ingressgateway
  namespace: default
spec: 
  selector:
    istio: ingressgateway
  servers:
  - port:
      number: 443
      name: https
      protocol: HTTPS
    tls:
      mode: SIMPLE
      credentialName: whereami-credentials #Must exist as a secret in the istio-system namespace
      minProtocolVersion: TLSV1_2
    hosts:
    - "*"
```

The `VirtualService` Object is configured to route all traffic accepted by the `Gateway` to the whereami Service on port 8080. In the istio World this is where you can configure more intelligent routing based on paths and headers. refer to [Istio VirtualService](https://istio.io/latest/docs/reference/config/networking/virtual-service/) doc for more details

```yaml
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: whereami
  namespace: default
spec:
  hosts:
  - "whereami.${DOMAIN}.com"
  gateways:
  - istio-ingressgateway
  http:
  - match:
    - uri:
        prefix: /
    route:
      - destination:
          port:
            number: 8080
          host: whereami.default.svc.cluster.local
```

With these resources, you are capable of securing your Ingress for production-ready traffic.

### Try it out

1. Download this repo and navigate to this folder

```bash
$ git clone https://github.com/GoogleCloudPlatform/gke-networking-recipes.git
Cloning into 'gke-networking-recipes'...

$ cd gke-networking-recipes/ingress/istio-ingress-e2e-tls
```

2. Deploy the cluster `gke-1` as specified in [cluster setup](../../cluster-setup.md)

3. Setup Istio

    * Download the Istio release.
      ```bash
      $ curl -L https://istio.io/downloadIstio | ISTIO_VERSION=1.7.5 sh -
      ```

    * [Prepare the GKE Cluster](https://istio.io/v1.7/docs/setup/platform-setup/gke/) to install Istio.

    * Install istio using the provided Operator file. For more details on how to cutomize Istio installation via the Operator API refer to this [doc](https://istio.io/latest/docs/setup/install/operator/)
      ```bash
      $ istioctl install -f operator.yaml
      ```
    
    * Verify the Istio installation
      ```bash
      $ kubectl get pods -n istio-system
      ```
    
    * Your output will be different but both the `istio-ingressgateway` and `istiod` should be installed and running

    * Enable Automatic sidecar injection on the default namespace
      ```bash
      $ kubectl label namespace default istio-injection=enabled 
      ```

4. Create a static public IP address in your project.

```bash
$ gcloud compute addresses create --global gke-istio-ingress
```

5. Get the reserved public IP address and register it with your domain. The remaining of this recipes will assume that whereami.whereami.abdel.cloud resolves to the Public IP of the Ingress.

```bash
gcloud compute addresses describe --global gke-istio-ingress 
```

6. Create an SSL policy. This policy specifies a broad set of modern ciphers and requires that clients negotiate using TLS 1.2 or higher.

```bash
$ gcloud compute ssl-policies create gke-ingress-ssl-policy \
    --profile MODERN \
    --min-tls-version 1.2
```
7. Create the TLS root certificate, certificates and private keys for the Istio-Ingressgateway. This is the TLS certificates that will be used by the GCLB to encrypt traffic before sending it to the Ingress-gateway. Replace ${DOMAIN} with the appropriate value.

```bash
$ mkdir certs
$ openssl req -x509 -sha256 -nodes -days 365 -newkey rsa:2048 -subj '/O=whereami.abdel.cloud Inc./CN=.cloud' -keyout certs/whereami.abdel.cloud.key -out certs/whereami.abdel.cloud.crt
$ openssl req -out certs/whereami.whereami.abdel.cloud.csr -newkey rsa:2048 -nodes -keyout certs/whereami.whereami.abdel.cloud.key -subj "/CN=whereami.whereami.abdel.cloud/O=abdel.cloud organization"
$ openssl x509 -req -days 365 -CA certs/whereami.abdel.cloud.crt -CAkey certs/whereami.abdel.cloud.key -set_serial 0 -in certs/whereami.whereami.abdel.cloud.csr -out certs/whereami.whereami.abdel.cloud.crt
```

8. Add the certificate and key to the istio-system namespace

```bash
$ kubectl create -n istio-system secret tls whereami-credentials --key=certs/whereami.whereami.abdel.cloud.key --cert=certs/whereami.whereami.abdel.cloud.crt
```

9. Now that all the Google Cloud resources have been created you can deploy your Kubernetes resources. Deploy the following manifest which deploys the whereami app and Service, the FrontendConfig and BackendConfig Objects, the ManagedCertificate, Ingress resource and Istio Objects (Gateway and VirtualService).

```bash
$ kubectl apply -f istio-ingress.yaml
managedcertificate.networking.gke.io/istio-ingress-cert created
frontendconfig.networking.gke.io/istio-ingress-fe-config created
backendconfig.cloud.google.com/istio-ingress-be-config created
ingress.networking.k8s.io/istio-ingress created
gateway.networking.istio.io/istio-ingressgateway created
virtualservice.networking.istio.io/whereami created
service/whereami created
deployment.apps/whereami created
```

10. It will take up to 15 minutes for everything to be provisioned. You can determine the status by checking the Ingress resource events. When it is ready, the events should look like the following:


```bash
$ kubectl describe ingress istio-ingress -n istio-system                  
Name:             istio-ingress
Namespace:        istio-system
Address:          34.120.200.50
Default backend:  istio-ingressgateway:443 (10.8.2.4:8443)
Rules:
  Host        Path  Backends
  ----        ----  --------
  *           *     istio-ingressgateway:443 (10.8.2.4:8443)
Annotations:  ingress.gcp.kubernetes.io/pre-shared-cert: mcrt-0300f011-c7a0-482f-81d6-27f96bf9a254
              ingress.kubernetes.io/backends: {"k8s1-8076ec74-istio-system-istio-ingressgateway-443-fcd32a34":"HEALTHY"}
              ingress.kubernetes.io/https-forwarding-rule: k8s2-fs-e0h00a6m-istio-system-istio-ingress-2j9y43h7
              ingress.kubernetes.io/https-target-proxy: k8s2-ts-e0h00a6m-istio-system-istio-ingress-2j9y43h7
              ingress.kubernetes.io/ssl-cert: mcrt-0300f011-c7a0-482f-81d6-27f96bf9a254
              ingress.kubernetes.io/url-map: k8s2-um-e0h00a6m-istio-system-istio-ingress-2j9y43h7
              kubernetes.io/ingress.allow-http: false
              kubernetes.io/ingress.global-static-ip-name: gke-istio-ingress
              networking.gke.io/managed-certificates: istio-ingress-cert
              networking.gke.io/v1beta1.FrontendConfig: istio-ingress-fe-config
Events:
  Type    Reason  Age                    From                     Message
  ----    ------  ----                   ----                     -------
  Normal  Sync    4m34s (x153 over 24h)  loadbalancer-controller  Scheduled for sync
```

11. Now use curl to connect your URL (remember to use your own domain for this) over HTTPS. The `whereami` app returns the output in JSON format so you also have to use `jq` to format it properly

```bash
curl -s https://whereami.${DOMAIN}.com
```

Your output should look something like:

```html
{
  "cluster_name": "gke-1",
  "headers": {
    "Accept": "*/*",
    "Content-Length": "0",
    "Host": "gke1.abdel.cloud",
    "User-Agent": "curl/7.72.0",
    "Via": "1.1 google",
    "X-B3-Parentspanid": "c9ccc927380735e6",
    "X-B3-Sampled": "0",
    "X-B3-Spanid": "ab35269f0f58964a",
    "X-B3-Traceid": "d56ac3dfe97c3f66c9ccc927380735e6",
    "X-Cloud-Trace-Context": "2c51f4218ff4ba563148c44c8f5409d4/9153278612683363795",
    "X-Envoy-Attempt-Count": "1",
    "X-Envoy-External-Address": "130.211.2.44",
    "X-Forwarded-Client-Cert": "By=spiffe://cluster.local/ns/default/sa/default;Hash=c25f091ddda2fec64169fa12412c2b2e56fa5e691394a97e4a4313f4a418a7a0;Subject=\"\";URI=spiffe://cluster.local/ns/istio-system/sa/istio-ingressgateway-service-account",
    "X-Forwarded-For": "80.216.72.128, 34.120.200.50,130.211.2.44",
    "X-Forwarded-Proto": "https",
    "X-Request-Id": "d0de1361-fc33-4340-b0cd-cf61afca854e"
  },
  "host_header": "gke1.abdel.cloud",
  "metadata": "echo_headers_enabled",
  "node_name": "gke-gke-1-default-pool-94ebed87-q2z9.c.lbg-project-278414.internal",
  "pod_name": "whereami-555cc58d9c-slkxr",
  "pod_name_emoji": "🇻",
  "project_id": "lbg-project-278414",
  "timestamp": "2020-12-04T09:23:11",
  "zone": "us-west1-a"
}
```

The `whereami` app we used return a lot of useful headers, here is an explanation of some of them:
- `X-Forwarded-Client-Cert`: Shows details on the mTLS authenticate chain. Since the traffic from the client to the whereami pod went throught the GCLB, the Istio-Ingressgateway than the application pod. We can see the identity of `whereami` pod (spiffe://cluster.local/ns/default/sa/default) and the `istio-ingressgateway` (spiffe://cluster.local/ns/istio-system/sa/istio-ingressgateway-service-account)
- `X-Forwarded-For`: Shows the chain of IP addresses from the client (80.216.72.128) to the GCLB IP(34.120.200.50,130) to the GCLB proxy IP (130.211.2.61). Yours will be different.
- `X-Forwarded-Proto`: Show that the connection from the GCLB to the istio-ingressgateway was made over https. The whereami app see's this as the call was forwarded from the istio-gateway.

12. You can try to reach your application on HTTP but you won't be able to.

```bash
$ curl -v http://whereami.${DOMAIN}.com

<!DOCTYPE html>
<html lang=en>
  <meta charset=utf-8>
  <meta name=viewport content="initial-scale=1, minimum-scale=1, width=device-width">
  <title>Error 404 (Not Found)!!1</title>
  <a href=//www.google.com/><span id=logo aria-label=Google></span></a>
  <p><b>404.</b> <ins>That’s an error.</ins>
  <p>The requested URL <code>/</code> was not found on this server.  <ins>That’s all we know.</ins>
```

This means the `allow-http` annotation is blocking http on the LoadBalancer.

### Cleanup

```bash
$ kubectl delete -f istio-ingress.yaml
$ gcloud compute addresses delete --global gke-istio-ingress
$ gcloud compute ssl-policies delete gke-ingress-ssl-policy
```
